{
    "docs": [
        {
            "location": "/", 
            "text": "Optim.jl\n\n\n\n\nHow\n\n\nOptim is registered in \nMETADATA.jl\n. This means that all you need to do to install Optim, is to run\n\n\nPkg\n.\nadd\n(\nOptim\n)\n\n\n\n\n\n\n\n\nWhat\n\n\nOptim is a Julia package for optimizing functions of various kinds. While there is some support for box constrained optimization, most of the solvers tries to find an $x$ that minimizes a function $f(x)$ without any constraints.  Thus, the main focus is on unconstrained optimization.\n\n\n\n\nWhy\n\n\nThere are many solvers available from both free and commercial sources, and many of them are accessible from Julia. Few of them are written in Julia. Performance-wise this is rarely a problem, as they are often written in either Fortran or C. However, solvers written directly in Julia does come with some advantages.\n\n\nWhen writing Julia software (packages) that require something to be optimized, the programmer can either choose to write their own optimization routine, or use one of the many available solvers. For example, this could be something from the \nNLOpt\n suite. This means adding a dependency which is not written in Julia, and more assumptions have to be made as to the environment the user is in. Does the user have the proper compilers? Is it possible to use GPL'ed code in the project? Optim is released under the MIT license, and installation is a simple \nPkg.add\n, so it really doesn't get much freer, easier, and lightweight than that.\n\n\nIt is also true, that using a solver written in C or Fortran makes it impossible to leverage one of the main benefits of Julia: multiple dispatch. Since Optim is entirely written in Julia, we can currently use the dispatch system to ease the use of custom preconditioners. A planned feature along these lines is to allow for user controlled choice of solvers for various steps in the algorithm, entirely based on dispatch, and not predefined possibilities chosen by the developers of Optim.\n\n\nBeing a Julia package also means that Optim has access to the automatic differentiation features through the packages in \nJuliaDiff\n.\n\n\n\n\nBut...\n\n\nOptim is a work in progress. There are still some rough edges to be sanded down, and features we want to implement. There are also planned breaking changes that are good to be aware of. Please see the section on Planned Changes.", 
            "title": "Home"
        }, 
        {
            "location": "/#optimjl", 
            "text": "", 
            "title": "Optim.jl"
        }, 
        {
            "location": "/#how", 
            "text": "Optim is registered in  METADATA.jl . This means that all you need to do to install Optim, is to run  Pkg . add ( Optim )", 
            "title": "How"
        }, 
        {
            "location": "/#what", 
            "text": "Optim is a Julia package for optimizing functions of various kinds. While there is some support for box constrained optimization, most of the solvers tries to find an $x$ that minimizes a function $f(x)$ without any constraints.  Thus, the main focus is on unconstrained optimization.", 
            "title": "What"
        }, 
        {
            "location": "/#why", 
            "text": "There are many solvers available from both free and commercial sources, and many of them are accessible from Julia. Few of them are written in Julia. Performance-wise this is rarely a problem, as they are often written in either Fortran or C. However, solvers written directly in Julia does come with some advantages.  When writing Julia software (packages) that require something to be optimized, the programmer can either choose to write their own optimization routine, or use one of the many available solvers. For example, this could be something from the  NLOpt  suite. This means adding a dependency which is not written in Julia, and more assumptions have to be made as to the environment the user is in. Does the user have the proper compilers? Is it possible to use GPL'ed code in the project? Optim is released under the MIT license, and installation is a simple  Pkg.add , so it really doesn't get much freer, easier, and lightweight than that.  It is also true, that using a solver written in C or Fortran makes it impossible to leverage one of the main benefits of Julia: multiple dispatch. Since Optim is entirely written in Julia, we can currently use the dispatch system to ease the use of custom preconditioners. A planned feature along these lines is to allow for user controlled choice of solvers for various steps in the algorithm, entirely based on dispatch, and not predefined possibilities chosen by the developers of Optim.  Being a Julia package also means that Optim has access to the automatic differentiation features through the packages in  JuliaDiff .", 
            "title": "Why"
        }, 
        {
            "location": "/#but", 
            "text": "Optim is a work in progress. There are still some rough edges to be sanded down, and features we want to implement. There are also planned breaking changes that are good to be aware of. Please see the section on Planned Changes.", 
            "title": "But..."
        }, 
        {
            "location": "/user/minimization/", 
            "text": "Minimizing a function\n\n\nTo show how the Optim package can be used, we implement the \nRosenbrock function\n, a classic problem in numerical optimization. We'll assume that you've already installed the Optim package using Julia's package manager. First, we load Optim and define the Rosenbrock function:\n\n\nusing\n \nOptim\n\n\nf\n(\nx\n)\n \n=\n \n(\n1.0\n \n-\n \nx\n[\n1\n])\n^\n2\n \n+\n \n100.0\n \n*\n \n(\nx\n[\n2\n]\n \n-\n \nx\n[\n1\n]\n^\n2\n)\n^\n2\n\n\n\n\n\n\nOnce we've defined this function, we can find the minimum of the Rosenbrock function using any of our favorite optimization algorithms. With a function defined, we just specify an initial point \nx\n and run:\n\n\noptimize\n(\nf\n,\n \n[\n0.0\n,\n \n0.0\n])\n\n\n\n\n\n\nOptim will default to using the Nelder-Mead method in this case, as we did not provide a gradient. This can also be explicitly specified using:\n\n\noptimize\n(\nf\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nNelderMead\n())\n\n\n\n\n\n\nOther solvers are available. Below, we use L-BFGS, a quasi-Newton method that requires a gradient. If we pass \nf\n alone, Optim will construct an approximate gradient for us using central finite differencing:\n\n\noptimize\n(\nf\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nLBFGS\n())\n\n\n\n\n\n\nAlternatively, the \nautodiff\n keyword will use atomatic differentiation to construct the gradient.\n\n\noptimize\n(\nf\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nLBFGS\n(),\n \nOptimizationOptions\n(\nautodiff\n \n=\n \ntrue\n))\n\n\n\n\n\n\nFor better performance and greater precision, you can pass your own gradient function. For the Rosenbrock example, the analytical gradient can be shown to be:\n\n\nfunction\n g\n!\n(\nx\n::\nVector\n,\n \nstorage\n::\nVector\n)\n\n\nstorage\n[\n1\n]\n \n=\n \n-\n2.0\n \n*\n \n(\n1.0\n \n-\n \nx\n[\n1\n])\n \n-\n \n400.0\n \n*\n \n(\nx\n[\n2\n]\n \n-\n \nx\n[\n1\n]\n^\n2\n)\n \n*\n \nx\n[\n1\n]\n\n\nstorage\n[\n2\n]\n \n=\n \n200.0\n \n*\n \n(\nx\n[\n2\n]\n \n-\n \nx\n[\n1\n]\n^\n2\n)\n\n\nend\n\n\n\n\n\n\nNote that the functions we're using to calculate the gradient (and later the Hessian \nh!\n) of the Rosenbrock function mutate a fixed-sized storage array, which is passed as an additional argument called \nstorage\n. By mutating a single array over many iterations, this style of function definition removes the sometimes considerable costs associated with allocating a new array during each call to the \ng!\n or \nh!\n functions. You can use \nOptim\n without manually defining a gradient or Hessian function, but if you do define these functions, they must take these two arguments in this order. Returning to our optimization, you simply pass \ng!\n together with \nf\n from before to use the gradient:\n\n\noptimize\n(\nf\n,\n \ng!\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nLBFGS\n())\n\n\n\n\n\n\nFor some methods, like simulated annealing, the gradient will be ignored:\n\n\noptimize\n(\nf\n,\n \ng!\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nSimulatedAnnealing\n())\n\n\n\n\n\n\nIn addition to providing gradients, you can provide a Hessian function \nh!\n as well. In our current case this is:\n\n\nfunction\n h\n!\n(\nx\n::\nVector\n,\n \nstorage\n::\nMatrix\n)\n\n\nstorage\n[\n1\n,\n \n1\n]\n \n=\n \n2.0\n \n-\n \n400.0\n \n*\n \nx\n[\n2\n]\n \n+\n \n1200.0\n \n*\n \nx\n[\n1\n]\n^\n2\n\n\nstorage\n[\n1\n,\n \n2\n]\n \n=\n \n-\n400.0\n \n*\n \nx\n[\n1\n]\n\n\nstorage\n[\n2\n,\n \n1\n]\n \n=\n \n-\n400.0\n \n*\n \nx\n[\n1\n]\n\n\nstorage\n[\n2\n,\n \n2\n]\n \n=\n \n200.0\n\n\nend\n\n\n\n\n\n\nNow we can use Newton's method for optimization by running:\n\n\noptimize\n(\nf\n,\n \ng!\n,\n \nh!\n,\n \n[\n0.0\n,\n \n0.0\n])\n\n\n\n\n\n\nWhich defaults to \nNewton()\n since a Hessian was provided. Like gradients, the Hessian function will be ignored if you use a method that does not require it:\n\n\noptimize\n(\nf\n,\n \ng!\n,\n \nh!\n,\n \n[\n0.0\n,\n \n0.0\n],\n \nLBFGS\n())\n\n\n\n\n\n\nNote that Optim will not generate approximate Hessians using finite differencing because of the potentially low accuracy of approximations to the Hessians. Other than Newton's method, none of the algorithms provided by the Optim package employ exact Hessians.\n\n\n\n\nObtaining results\n\n\nAfter we have our results in \nres\n, we can use the API for getting optimization results. This consists of a collection of functions. They are not exported, so they have to be prefixed by \nOptim.\n. Say we do the following optimization:\n\n\nres\n \n=\n \noptimize\n(\nx\n-\ndot\n(\nx\n,[\n1\n \n0.\n \n0\n;\n \n0\n \n3\n \n0\n;\n \n0\n \n0\n \n1\n]\n*\nx\n),\n \nzeros\n(\n3\n))\n\n\n\n\n\n\nIf we can't remember what method we used, we simply use\n\n\nOptim\n.\nmethod\n(\nres\n)\n\n\n\n\n\n\nwhich will return \n\"Nelder Mead\"\n. A bit more useful information is the minimizer and minimum of the objective functions, which can be found using\n\n\njulia\n \nOptim\n.\nminimizer\n(\nres\n)\n\n\n3-element Array{Float64,1}:\n\n\n -0.499921\n\n\n -0.3333  \n\n\n -1.49994\n\n\n\njulia\n \nOptim\n.\nminimum\n(\nres\n)\n\n\n -2.8333333205768865\n\n\n\n\n\n\n\n\nComplete list of functions\n\n\nA complete list of functions can be found below.\n\n\nDefined for all methods:\n\n\n\n\nmethod(res)\n\n\nminimizer(res)\n\n\nminimum(res)\n\n\niterations(res)\n\n\niteration_limit_reached(res)\n\n\ntrace(res)\n\n\nx_trace(res)\n\n\nf_trace(res)\n\n\nf_calls(res)\n\n\nconverged(res)\n\n\n\n\nDefined for univariate optimization:\n\n\n\n\nlower_bound(res)\n\n\nupper_bound(res)\n\n\nx_lower_trace(res)\n\n\nx_upper_trace(res)\n\n\nrel_tol(res)\n\n\nabs_tol(res)\n\n\n\n\nDefined for multivariate optimization:\n\n\n\n\ng_norm_trace(res)\n\n\ng_calls(res)\n\n\nx_converged(res)\n\n\nf_converged(res)\n\n\ng_converged(res)\n\n\ninitial_state(res)", 
            "title": "Minimizing a function"
        }, 
        {
            "location": "/user/minimization/#minimizing-a-function", 
            "text": "To show how the Optim package can be used, we implement the  Rosenbrock function , a classic problem in numerical optimization. We'll assume that you've already installed the Optim package using Julia's package manager. First, we load Optim and define the Rosenbrock function:  using   Optim  f ( x )   =   ( 1.0   -   x [ 1 ]) ^ 2   +   100.0   *   ( x [ 2 ]   -   x [ 1 ] ^ 2 ) ^ 2   Once we've defined this function, we can find the minimum of the Rosenbrock function using any of our favorite optimization algorithms. With a function defined, we just specify an initial point  x  and run:  optimize ( f ,   [ 0.0 ,   0.0 ])   Optim will default to using the Nelder-Mead method in this case, as we did not provide a gradient. This can also be explicitly specified using:  optimize ( f ,   [ 0.0 ,   0.0 ],   NelderMead ())   Other solvers are available. Below, we use L-BFGS, a quasi-Newton method that requires a gradient. If we pass  f  alone, Optim will construct an approximate gradient for us using central finite differencing:  optimize ( f ,   [ 0.0 ,   0.0 ],   LBFGS ())   Alternatively, the  autodiff  keyword will use atomatic differentiation to construct the gradient.  optimize ( f ,   [ 0.0 ,   0.0 ],   LBFGS (),   OptimizationOptions ( autodiff   =   true ))   For better performance and greater precision, you can pass your own gradient function. For the Rosenbrock example, the analytical gradient can be shown to be:  function  g ! ( x :: Vector ,   storage :: Vector )  storage [ 1 ]   =   - 2.0   *   ( 1.0   -   x [ 1 ])   -   400.0   *   ( x [ 2 ]   -   x [ 1 ] ^ 2 )   *   x [ 1 ]  storage [ 2 ]   =   200.0   *   ( x [ 2 ]   -   x [ 1 ] ^ 2 )  end   Note that the functions we're using to calculate the gradient (and later the Hessian  h! ) of the Rosenbrock function mutate a fixed-sized storage array, which is passed as an additional argument called  storage . By mutating a single array over many iterations, this style of function definition removes the sometimes considerable costs associated with allocating a new array during each call to the  g!  or  h!  functions. You can use  Optim  without manually defining a gradient or Hessian function, but if you do define these functions, they must take these two arguments in this order. Returning to our optimization, you simply pass  g!  together with  f  from before to use the gradient:  optimize ( f ,   g! ,   [ 0.0 ,   0.0 ],   LBFGS ())   For some methods, like simulated annealing, the gradient will be ignored:  optimize ( f ,   g! ,   [ 0.0 ,   0.0 ],   SimulatedAnnealing ())   In addition to providing gradients, you can provide a Hessian function  h!  as well. In our current case this is:  function  h ! ( x :: Vector ,   storage :: Matrix )  storage [ 1 ,   1 ]   =   2.0   -   400.0   *   x [ 2 ]   +   1200.0   *   x [ 1 ] ^ 2  storage [ 1 ,   2 ]   =   - 400.0   *   x [ 1 ]  storage [ 2 ,   1 ]   =   - 400.0   *   x [ 1 ]  storage [ 2 ,   2 ]   =   200.0  end   Now we can use Newton's method for optimization by running:  optimize ( f ,   g! ,   h! ,   [ 0.0 ,   0.0 ])   Which defaults to  Newton()  since a Hessian was provided. Like gradients, the Hessian function will be ignored if you use a method that does not require it:  optimize ( f ,   g! ,   h! ,   [ 0.0 ,   0.0 ],   LBFGS ())   Note that Optim will not generate approximate Hessians using finite differencing because of the potentially low accuracy of approximations to the Hessians. Other than Newton's method, none of the algorithms provided by the Optim package employ exact Hessians.", 
            "title": "Minimizing a function"
        }, 
        {
            "location": "/user/minimization/#obtaining-results", 
            "text": "After we have our results in  res , we can use the API for getting optimization results. This consists of a collection of functions. They are not exported, so they have to be prefixed by  Optim. . Say we do the following optimization:  res   =   optimize ( x - dot ( x ,[ 1   0.   0 ;   0   3   0 ;   0   0   1 ] * x ),   zeros ( 3 ))   If we can't remember what method we used, we simply use  Optim . method ( res )   which will return  \"Nelder Mead\" . A bit more useful information is the minimizer and minimum of the objective functions, which can be found using  julia   Optim . minimizer ( res )  3-element Array{Float64,1}:   -0.499921   -0.3333     -1.49994  julia   Optim . minimum ( res )   -2.8333333205768865", 
            "title": "Obtaining results"
        }, 
        {
            "location": "/user/minimization/#complete-list-of-functions", 
            "text": "A complete list of functions can be found below.  Defined for all methods:   method(res)  minimizer(res)  minimum(res)  iterations(res)  iteration_limit_reached(res)  trace(res)  x_trace(res)  f_trace(res)  f_calls(res)  converged(res)   Defined for univariate optimization:   lower_bound(res)  upper_bound(res)  x_lower_trace(res)  x_upper_trace(res)  rel_tol(res)  abs_tol(res)   Defined for multivariate optimization:   g_norm_trace(res)  g_calls(res)  x_converged(res)  f_converged(res)  g_converged(res)  initial_state(res)", 
            "title": "Complete list of functions"
        }, 
        {
            "location": "/user/config/", 
            "text": "Configurable options\n\n\nThere are several options that simply take on some default values if the user doensn't supply anything else than a function (and gradient) and a starting point.\n\n\n\n\nSolver options\n\n\nThere quite a few different solvers available in Optim, and they are all listed below. Notice that the constructors are written without input here, but they generally take keywords to tweak the way they work. See the pages describing each solver for more detail.\n\n\nRequires only a function handle:\n\n\n\n\nNelderMead()\n\n\nSimulatedAnnealing()\n\n\n\n\nRequires a function and gradient (will be approximated if omitted):\n\n\n\n\nBFGS()\n\n\nLBFGS()\n\n\nConjugateGradient()\n\n\nGradientDescent()\n\n\nMomentumGradientDescent()\n\n\nAcceleratedGradientDescent()\n\n\n\n\nRequires a function, a gradient, and a Hessian (cannot be omitted):\n\n\n\n\nNewton()\n\n\n\n\nBox constrained minimization:\n\n\n\n\nFminbox()\n\n\n\n\nSpecial methods for univariate optimization:\n\n\n\n\nBrent()\n\n\nGoldenSection()\n\n\n\n\n\n\nGeneral Options\n\n\nIn addition to the solver, you can alter the behavior of the Optim package by using the following keywords:\n\n\n\n\nx_tol\n: What is the threshold for determining convergence in the input vector? Defaults to \n1e-32\n.\n\n\nf_tol\n: What is the threshold for determining convergence in the objective value? Defaults to \n1e-32\n.\n\n\ng_tol\n: What is the threshold for determining convergence in the gradient? Defaults to \n1e-8\n. For gradient free methods, this will control the main convergence tolerance, which is solver specific.\n\n\niterations\n: How many iterations will run before the algorithm gives up? Defaults to \n1_000\n.\n\n\nstore_trace\n: Should a trace of the optimization algorithm's state be stored? Defaults to \nfalse\n.\n\n\nshow_trace\n: Should a trace of the optimization algorithm's state be shown on \nSTDOUT\n? Defaults to \nfalse\n.\n\n\nextended_trace\n: Save additional information. Solver dependent.\n\n\nautodiff\n: When only an objective function is provided, use automatic differentiation to compute exact numerical gradients. If not, finite differencing will be used. This functionality is experimental. Defaults to \nfalse\n.\n\n\nshow_every\n: Trace output is printed every \nshow_every\nth iteration.\n\n\n\n\nWe currently recommend the statically dispatched interface by using the \nOptimizationOptions\n  constructor:\n\n\nres\n \n=\n \noptimize\n(\nf\n,\n \ng!\n,\n\n               \n[\n0.0\n,\n \n0.0\n],\n\n               \nGradientDescent\n(),\n\n               \nOptimizationOptions\n(\ng_tol\n \n=\n \n1e-12\n,\n\n                                   \niterations\n \n=\n \n10\n,\n\n                                   \nstore_trace\n \n=\n \ntrue\n,\n\n                                   \nshow_trace\n \n=\n \nfalse\n))\n\n\n\n\n\n\nAnother interface is also available, based directly on keywords:\n\n\nres\n \n=\n \noptimize\n(\nf\n,\n \ng!\n,\n\n               \n[\n0.0\n,\n \n0.0\n],\n\n               \nmethod\n \n=\n \nGradientDescent\n(),\n\n               \ng_tol\n \n=\n \n1e-12\n,\n\n               \niterations\n \n=\n \n10\n,\n\n               \nstore_trace\n \n=\n \ntrue\n,\n\n               \nshow_trace\n \n=\n \nfalse\n)\n\n\n\n\n\n\nNotice the need to specify the method using a keyword if this syntax is used. It is likely that this will be deprecated in the future.", 
            "title": "Configurable Options"
        }, 
        {
            "location": "/user/config/#configurable-options", 
            "text": "There are several options that simply take on some default values if the user doensn't supply anything else than a function (and gradient) and a starting point.", 
            "title": "Configurable options"
        }, 
        {
            "location": "/user/config/#solver-options", 
            "text": "There quite a few different solvers available in Optim, and they are all listed below. Notice that the constructors are written without input here, but they generally take keywords to tweak the way they work. See the pages describing each solver for more detail.  Requires only a function handle:   NelderMead()  SimulatedAnnealing()   Requires a function and gradient (will be approximated if omitted):   BFGS()  LBFGS()  ConjugateGradient()  GradientDescent()  MomentumGradientDescent()  AcceleratedGradientDescent()   Requires a function, a gradient, and a Hessian (cannot be omitted):   Newton()   Box constrained minimization:   Fminbox()   Special methods for univariate optimization:   Brent()  GoldenSection()", 
            "title": "Solver options"
        }, 
        {
            "location": "/user/config/#general-options", 
            "text": "In addition to the solver, you can alter the behavior of the Optim package by using the following keywords:   x_tol : What is the threshold for determining convergence in the input vector? Defaults to  1e-32 .  f_tol : What is the threshold for determining convergence in the objective value? Defaults to  1e-32 .  g_tol : What is the threshold for determining convergence in the gradient? Defaults to  1e-8 . For gradient free methods, this will control the main convergence tolerance, which is solver specific.  iterations : How many iterations will run before the algorithm gives up? Defaults to  1_000 .  store_trace : Should a trace of the optimization algorithm's state be stored? Defaults to  false .  show_trace : Should a trace of the optimization algorithm's state be shown on  STDOUT ? Defaults to  false .  extended_trace : Save additional information. Solver dependent.  autodiff : When only an objective function is provided, use automatic differentiation to compute exact numerical gradients. If not, finite differencing will be used. This functionality is experimental. Defaults to  false .  show_every : Trace output is printed every  show_every th iteration.   We currently recommend the statically dispatched interface by using the  OptimizationOptions   constructor:  res   =   optimize ( f ,   g! , \n                [ 0.0 ,   0.0 ], \n                GradientDescent (), \n                OptimizationOptions ( g_tol   =   1e-12 , \n                                    iterations   =   10 , \n                                    store_trace   =   true , \n                                    show_trace   =   false ))   Another interface is also available, based directly on keywords:  res   =   optimize ( f ,   g! , \n                [ 0.0 ,   0.0 ], \n                method   =   GradientDescent (), \n                g_tol   =   1e-12 , \n                iterations   =   10 , \n                store_trace   =   true , \n                show_trace   =   false )   Notice the need to specify the method using a keyword if this syntax is used. It is likely that this will be deprecated in the future.", 
            "title": "General Options"
        }, 
        {
            "location": "/user/tipsandtricks/", 
            "text": "Dealing with constant parameters\n\n\nIn many applications, there may be factors that are relevant to the function evaluations, but are fixed throughout the optimization. An obvious example is using data in a likelihood function, but it could also be parameters we wish to hold constant.\n\n\nConsider a squared error loss function that depends on some data \nx\n and \ny\n, and parameters \nbetas\n. As far as the solver is concerned, there should only be one input argument to the function we want to minimize, call it \nsqerror\n.\n\n\nThe problem is that we want to optimize a function \nsqerror\n that really depends on three inputs, and two of them are constant throught the optimization procedure. To do this, we need to define the variables \nx\n and \ny\n\n\nx\n \n=\n \n[\n1.0\n,\n \n2.0\n,\n \n3.0\n]\n\n\ny\n \n=\n \n1.0\n \n+\n \n2.0\n \n*\n \nx\n \n+\n \n[\n-\n0.3\n,\n \n0.3\n,\n \n-\n0.1\n]\n\n\n\n\n\n\nWe then simply define a function in three variables\n\n\nfunction\n sqerror\n(\nbetas\n,\n \nX\n,\n \nY\n)\n\n    \nerr\n \n=\n \n0.0\n\n    \nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nX\n)\n\n        \npred_i\n \n=\n \nbetas\n[\n1\n]\n \n+\n \nbetas\n[\n2\n]\n \n*\n \nX\n[\ni\n]\n\n        \nerr\n \n+=\n \n(\nY\n[\ni\n]\n \n-\n \npred_i\n)\n^\n2\n\n    \nend\n\n    \nreturn\n \nerr\n\n\nend\n\n\n\n\n\n\nand then optimize the following anonymous function\n\n\nres\n \n=\n \noptimize\n(\nb\n \n-\n \nsqerror\n(\nb\n,\n \nx\n,\n \ny\n),\n \n[\n0.0\n,\n \n0.0\n])\n\n\n\n\n\n\nAlternatively, we can define a closure \nsqerror(betas)\n that is aware of the variables we just defined\n\n\nfunction\n sqerror\n(\nbetas\n)\n\n    \nerr\n \n=\n \n0.0\n\n    \nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nx\n)\n\n        \npred_i\n \n=\n \nbetas\n[\n1\n]\n \n+\n \nbetas\n[\n2\n]\n \n*\n \nx\n[\ni\n]\n\n        \nerr\n \n+=\n \n(\ny\n[\ni\n]\n \n-\n \npred_i\n)\n^\n2\n\n    \nend\n\n    \nreturn\n \nerr\n\n\nend\n\n\n\n\n\n\nWe can then optimize the \nsqerror\n function just like any other function\n\n\nres\n \n=\n \noptimize\n(\nsqerror\n,\n \n[\n0.0\n,\n \n0.0\n])\n\n\n\n\n\n\n\n\nAvoid repeating computations\n\n\nSay you are optimizing a function\n\n\nf\n(\nx\n)\n \n=\n \nx\n[\n1\n]\n^\n2\n+\nx\n[\n2\n]\n^\n2\n\n\ng!\n(\nx\n,\n \nstor\n)\n \n=\n \n[\n2\nx\n[\n1\n],\n \n2\nx\n[\n2\n]]\n\n\n\n\n\n\nIn this situation, no calculations from \nf\n could be reused in \ng!\n. However, sometimes there is a substantial similarity between the objective function, and gradient, and some calculations can be reused. The trick here is essentially the same as above. We use a closure or an anonymous function. Basically, we define\n\n\nfunction\n calculate_common\n!\n(\nx\n,\n \nlast_x\n,\n \nbuffer\n)\n\n    \nif\n \nx\n \n!=\n \nlast_x\n\n        \ncopy!\n(\nlast_x\n,\n \nx\n)\n\n        \n#do whatever common calculations and save to buffer\n\n    \nend\n\n\nend\n\n\n\nfunction\n f\n(\nx\n,\n \nbuffer\n,\n \nlast_x\n)\n\n    \ncalculate_common!\n(\nx\n,\n \nlast_x\n,\n \nbuffer\n)\n\n    \nf_body\n \n# depends on buffer\n\n\nend\n\n\n\nfunction\n g\n!\n(\nx\n,\n \nstor\n,\n \nbuffer\n,\n \nlast_x\n)\n\n    \ncalculate_common!\n(\nx\n,\n \nlast_x\n,\n \nbuffer\n)\n\n    \ng_body!\n \n# depends on buffer\n\n\nend\n\n\n\n\n\n\nand then the following\n\n\nusing\n \nOptim\n\n\nx0\n \n=\n \n...\n\n\nbuffer\n \n=\n \nArray\n(\n...\n)\n \n# Preallocate an appropriate buffer\n\n\nlast_x\n \n=\n \nsimilar\n(\nx0\n)\n\n\ndf\n \n=\n \nTwiceDifferentiableFunction\n(\nx\n \n-\n \nf\n(\nx\n,\n \nbuffer\n,\n \nx0\n),\n\n                                \n(\nx\n,\n \nstor\n)\n \n-\n \ng!\n(\nx\n,\n \nstor\n,\n \nbuffer\n,\n \nlast_x\n))\n\n\noptimize\n(\ndf\n,\n \nx0\n)\n\n\n\n\n\n\n\n\nProvide gradients\n\n\nAs mentioned in the general introduction, passing analytical gradients can have an impact on performance. To show an example of this, consider the separable extension of the Rosenbrock function in dimension 5000, see \nSROSENBR\n in CUTEst.\n\n\nBelow, we use the gradients and objective functions from \nmastsif\n through \nCUTEst.jl\n. We only show the first five iterations of an attempt to minimize the function using Gradient Descent.\n\n\njulia\n \n@\ntime\n \noptimize\n(\nf\n,\n \nx0\n,\n \nGradientDescent\n(),\n\n\n\n                      OptimizationOptions(show_trace=true, iterations = 5))\n\n\nIter     Function value   Gradient norm\n\n\n     0     4.850000e+04     2.116000e+02\n\n\n     1     1.018734e+03     2.704951e+01\n\n\n     2     3.468449e+00     5.721261e-01\n\n\n     3     2.966899e+00     2.638790e-02\n\n\n     4     2.511859e+00     5.237768e-01\n\n\n     5     2.107853e+00     1.020287e-01\n\n\n 21.731129 seconds (1.61 M allocations: 63.434 MB, 0.03% gc time)\n\n\nResults of Optimization Algorithm\n\n\n * Algorithm: Gradient Descent\n\n\n * Starting Point: [1.2,1.0, ...]\n\n\n * Minimizer: [1.0287767703731154,1.058769439356144, ...]\n\n\n * Minimum: 2.107853e+00\n\n\n * Iterations: 5\n\n\n * Convergence: false\n\n\n   * |x - x\n| \n 1.0e-32: false\n\n\n   * |f(x) - f(x\n)| / |f(x)| \n 1.0e-32: false\n\n\n   * |g(x)| \n 1.0e-08: false\n\n\n   * Reached Maximum Number of Iterations: true\n\n\n * Objective Function Calls: 23\n\n\n * Gradient Calls: 23\n\n\n\njulia\n \n@\ntime\n \noptimize\n(\nf\n,\n \ng!\n,\n \nx0\n,\n \nGradientDescent\n(),\n\n\n\n                      OptimizationOptions(show_trace=true, iterations = 5))\n\n\nIter     Function value   Gradient norm\n\n\n     0     4.850000e+04     2.116000e+02\n\n\n     1     1.018769e+03     2.704998e+01\n\n\n     2     3.468488e+00     5.721481e-01\n\n\n     3     2.966900e+00     2.638792e-02\n\n\n     4     2.511828e+00     5.237919e-01\n\n\n     5     2.107802e+00     1.020415e-01\n\n\n  0.009889 seconds (915 allocations: 270.266 KB)\n\n\nResults of Optimization Algorithm\n\n\n * Algorithm: Gradient Descent\n\n\n * Starting Point: [1.2,1.0, ...]\n\n\n * Minimizer: [1.0287763814102757,1.05876866832087, ...]\n\n\n * Minimum: 2.107802e+00\n\n\n * Iterations: 5\n\n\n * Convergence: false\n\n\n   * |x - x\n| \n 1.0e-32: false\n\n\n   * |f(x) - f(x\n)| / |f(x)| \n 1.0e-32: false\n\n\n   * |g(x)| \n 1.0e-08: false\n\n\n   * Reached Maximum Number of Iterations: true\n\n\n * Objective Function Calls: 23\n\n\n * Gradient Calls: 23\n\n\n\n\n\n\nThe objective has obtained a value that is very similar between the two runs, but the run with the analytical gradient is way faster.  It is possible that the finite differences code can be improved, but generally the optimization will be slowed down by all the function evaluations required to do the central finite differences calculations.", 
            "title": "Tips and tricks"
        }, 
        {
            "location": "/user/tipsandtricks/#dealing-with-constant-parameters", 
            "text": "In many applications, there may be factors that are relevant to the function evaluations, but are fixed throughout the optimization. An obvious example is using data in a likelihood function, but it could also be parameters we wish to hold constant.  Consider a squared error loss function that depends on some data  x  and  y , and parameters  betas . As far as the solver is concerned, there should only be one input argument to the function we want to minimize, call it  sqerror .  The problem is that we want to optimize a function  sqerror  that really depends on three inputs, and two of them are constant throught the optimization procedure. To do this, we need to define the variables  x  and  y  x   =   [ 1.0 ,   2.0 ,   3.0 ]  y   =   1.0   +   2.0   *   x   +   [ - 0.3 ,   0.3 ,   - 0.1 ]   We then simply define a function in three variables  function  sqerror ( betas ,   X ,   Y ) \n     err   =   0.0 \n     for   i   in   1 : length ( X ) \n         pred_i   =   betas [ 1 ]   +   betas [ 2 ]   *   X [ i ] \n         err   +=   ( Y [ i ]   -   pred_i ) ^ 2 \n     end \n     return   err  end   and then optimize the following anonymous function  res   =   optimize ( b   -   sqerror ( b ,   x ,   y ),   [ 0.0 ,   0.0 ])   Alternatively, we can define a closure  sqerror(betas)  that is aware of the variables we just defined  function  sqerror ( betas ) \n     err   =   0.0 \n     for   i   in   1 : length ( x ) \n         pred_i   =   betas [ 1 ]   +   betas [ 2 ]   *   x [ i ] \n         err   +=   ( y [ i ]   -   pred_i ) ^ 2 \n     end \n     return   err  end   We can then optimize the  sqerror  function just like any other function  res   =   optimize ( sqerror ,   [ 0.0 ,   0.0 ])", 
            "title": "Dealing with constant parameters"
        }, 
        {
            "location": "/user/tipsandtricks/#avoid-repeating-computations", 
            "text": "Say you are optimizing a function  f ( x )   =   x [ 1 ] ^ 2 + x [ 2 ] ^ 2  g! ( x ,   stor )   =   [ 2 x [ 1 ],   2 x [ 2 ]]   In this situation, no calculations from  f  could be reused in  g! . However, sometimes there is a substantial similarity between the objective function, and gradient, and some calculations can be reused. The trick here is essentially the same as above. We use a closure or an anonymous function. Basically, we define  function  calculate_common ! ( x ,   last_x ,   buffer ) \n     if   x   !=   last_x \n         copy! ( last_x ,   x ) \n         #do whatever common calculations and save to buffer \n     end  end  function  f ( x ,   buffer ,   last_x ) \n     calculate_common! ( x ,   last_x ,   buffer ) \n     f_body   # depends on buffer  end  function  g ! ( x ,   stor ,   buffer ,   last_x ) \n     calculate_common! ( x ,   last_x ,   buffer ) \n     g_body!   # depends on buffer  end   and then the following  using   Optim  x0   =   ...  buffer   =   Array ( ... )   # Preallocate an appropriate buffer  last_x   =   similar ( x0 )  df   =   TwiceDifferentiableFunction ( x   -   f ( x ,   buffer ,   x0 ), \n                                 ( x ,   stor )   -   g! ( x ,   stor ,   buffer ,   last_x ))  optimize ( df ,   x0 )", 
            "title": "Avoid repeating computations"
        }, 
        {
            "location": "/user/tipsandtricks/#provide-gradients", 
            "text": "As mentioned in the general introduction, passing analytical gradients can have an impact on performance. To show an example of this, consider the separable extension of the Rosenbrock function in dimension 5000, see  SROSENBR  in CUTEst.  Below, we use the gradients and objective functions from  mastsif  through  CUTEst.jl . We only show the first five iterations of an attempt to minimize the function using Gradient Descent.  julia   @ time   optimize ( f ,   x0 ,   GradientDescent (),                        OptimizationOptions(show_trace=true, iterations = 5))  Iter     Function value   Gradient norm       0     4.850000e+04     2.116000e+02       1     1.018734e+03     2.704951e+01       2     3.468449e+00     5.721261e-01       3     2.966899e+00     2.638790e-02       4     2.511859e+00     5.237768e-01       5     2.107853e+00     1.020287e-01   21.731129 seconds (1.61 M allocations: 63.434 MB, 0.03% gc time)  Results of Optimization Algorithm   * Algorithm: Gradient Descent   * Starting Point: [1.2,1.0, ...]   * Minimizer: [1.0287767703731154,1.058769439356144, ...]   * Minimum: 2.107853e+00   * Iterations: 5   * Convergence: false     * |x - x |   1.0e-32: false     * |f(x) - f(x )| / |f(x)|   1.0e-32: false     * |g(x)|   1.0e-08: false     * Reached Maximum Number of Iterations: true   * Objective Function Calls: 23   * Gradient Calls: 23  julia   @ time   optimize ( f ,   g! ,   x0 ,   GradientDescent (),                        OptimizationOptions(show_trace=true, iterations = 5))  Iter     Function value   Gradient norm       0     4.850000e+04     2.116000e+02       1     1.018769e+03     2.704998e+01       2     3.468488e+00     5.721481e-01       3     2.966900e+00     2.638792e-02       4     2.511828e+00     5.237919e-01       5     2.107802e+00     1.020415e-01    0.009889 seconds (915 allocations: 270.266 KB)  Results of Optimization Algorithm   * Algorithm: Gradient Descent   * Starting Point: [1.2,1.0, ...]   * Minimizer: [1.0287763814102757,1.05876866832087, ...]   * Minimum: 2.107802e+00   * Iterations: 5   * Convergence: false     * |x - x |   1.0e-32: false     * |f(x) - f(x )| / |f(x)|   1.0e-32: false     * |g(x)|   1.0e-08: false     * Reached Maximum Number of Iterations: true   * Objective Function Calls: 23   * Gradient Calls: 23   The objective has obtained a value that is very similar between the two runs, but the run with the analytical gradient is way faster.  It is possible that the finite differences code can be improved, but generally the optimization will be slowed down by all the function evaluations required to do the central finite differences calculations.", 
            "title": "Provide gradients"
        }, 
        {
            "location": "/user/planned/", 
            "text": "Planned Changes\n\n\nSome features and changes have been identified as \"wanted\". Some of these are breaking changes, but for the better.\n\n\nOne important change is the ordering of the preallocated array, and the current iterate in the mutating gradient and Hessian functions. Currently, we have\n\n\ng!\n(\nx\n,\n \nstor\n)\n\n\nh!\n(\nx\n,\n \nstor\n)\n\n\n\n\n\n\nBut with the next version of Optim, we intend to be more in line with the rest of the Julia ecosystem and write\n\n\ng!\n(\nstor\n,\n \nx\n)\n\n\nh!\n(\nstor\n,\n \nx\n)\n\n\n\n\n\n\n\u00cdt is also quite possible that the keywords-style tuning of options will be removed. Instead of writing \noptimize(..., g_tol = 1e-4)\n users will have to write \noptimize(..., OptimizationOptions(g_tol = 1e-4))\n. Obviously, it is a bit more verbose, but it will allow the internals to work entirely through dispatch, and avoid a lot of keyword handling. Simpler code is easier to maintain, and less prone to bugs.", 
            "title": "Planned Changes"
        }, 
        {
            "location": "/user/planned/#planned-changes", 
            "text": "Some features and changes have been identified as \"wanted\". Some of these are breaking changes, but for the better.  One important change is the ordering of the preallocated array, and the current iterate in the mutating gradient and Hessian functions. Currently, we have  g! ( x ,   stor )  h! ( x ,   stor )   But with the next version of Optim, we intend to be more in line with the rest of the Julia ecosystem and write  g! ( stor ,   x )  h! ( stor ,   x )   \u00cdt is also quite possible that the keywords-style tuning of options will be removed. Instead of writing  optimize(..., g_tol = 1e-4)  users will have to write  optimize(..., OptimizationOptions(g_tol = 1e-4)) . Obviously, it is a bit more verbose, but it will allow the internals to work entirely through dispatch, and avoid a lot of keyword handling. Simpler code is easier to maintain, and less prone to bugs.", 
            "title": "Planned Changes"
        }, 
        {
            "location": "/algo/nelder_mead/", 
            "text": "Nelder-Mead\n\n\nNelder-Mead is currently the standard algorithm when no derivatives are provided.\n\n\n\n\nConstructor\n\n\nNelderMead\n(;\n \na\n \n=\n \n1.0\n,\n\n             \ng\n \n=\n \n2.0\n,\n\n             \nb\n \n=\n \n0.5\n)\n\n\n\n\n\n\n\n\nDescription\n\n\nOur current implementation of the Nelder-Mead algorithm follows the original implementation very closely, see Nelder and Mead (1965). This means that there is scope for improvement, but also that it should be quite clear what is going on in the code relative to the original paper.\n\n\nInstead of using gradient information, we keep track of the function value at a number of points in the search space. Together, the points form a simplex. Given a simplex, we can perform one of four actions: reflect, expand, contract, or shrink. Basically, the goal is to iteratively replace the worst point with a better point. More information can be found in Nelder and Mead (1965) or Gao and Han (2010).\n\n\nThe stopping rule is the same as in the original paper, and is basically the standard error of the function values at the vertices. To set the tolerance level for this convergence criterion, set the \ng_tol\n level as described in the Configurable Options section.\n\n\nWhen the solver finishes, we return a minimizer which is either the centroid or one of the vertices. The function value at the centroid adds a function evaluation, as we need to evaluate the objection at the centroid to choose the smallest function value. Howeever, even if the function value at the centroid can be returned as the minimum, we do not trace it during the optimization iterations. This is to avoid too many evaluations of the objective function which can be computationally expensive. Typically, there should be no more than twice as many \nf_calls\n than \niterations\n, and adding an evaluation at the centroid when \ntracing\n could considerably increase the total run-time of the algorithm.\n\n\n\n\nExample\n\n\n\n\nReferences\n\n\nNelder, John A. and R. Mead (1965). \"A simplex method for function minimization\". Computer Journal 7: 308\u2013313. doi:10.1093/comjnl/7.4.308. Gao, Fuchang and Lixing Han (2010). \"Implementing the Nelder-Mead simplex algorithm with adaptive parameters\". Computational Optimization and Applications [DOI 10.1007/s10589-010-9329-3]", 
            "title": "Nelder Mead"
        }, 
        {
            "location": "/algo/nelder_mead/#nelder-mead", 
            "text": "Nelder-Mead is currently the standard algorithm when no derivatives are provided.", 
            "title": "Nelder-Mead"
        }, 
        {
            "location": "/algo/nelder_mead/#constructor", 
            "text": "NelderMead (;   a   =   1.0 , \n              g   =   2.0 , \n              b   =   0.5 )", 
            "title": "Constructor"
        }, 
        {
            "location": "/algo/nelder_mead/#description", 
            "text": "Our current implementation of the Nelder-Mead algorithm follows the original implementation very closely, see Nelder and Mead (1965). This means that there is scope for improvement, but also that it should be quite clear what is going on in the code relative to the original paper.  Instead of using gradient information, we keep track of the function value at a number of points in the search space. Together, the points form a simplex. Given a simplex, we can perform one of four actions: reflect, expand, contract, or shrink. Basically, the goal is to iteratively replace the worst point with a better point. More information can be found in Nelder and Mead (1965) or Gao and Han (2010).  The stopping rule is the same as in the original paper, and is basically the standard error of the function values at the vertices. To set the tolerance level for this convergence criterion, set the  g_tol  level as described in the Configurable Options section.  When the solver finishes, we return a minimizer which is either the centroid or one of the vertices. The function value at the centroid adds a function evaluation, as we need to evaluate the objection at the centroid to choose the smallest function value. Howeever, even if the function value at the centroid can be returned as the minimum, we do not trace it during the optimization iterations. This is to avoid too many evaluations of the objective function which can be computationally expensive. Typically, there should be no more than twice as many  f_calls  than  iterations , and adding an evaluation at the centroid when  tracing  could considerably increase the total run-time of the algorithm.", 
            "title": "Description"
        }, 
        {
            "location": "/algo/nelder_mead/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/algo/nelder_mead/#references", 
            "text": "Nelder, John A. and R. Mead (1965). \"A simplex method for function minimization\". Computer Journal 7: 308\u2013313. doi:10.1093/comjnl/7.4.308. Gao, Fuchang and Lixing Han (2010). \"Implementing the Nelder-Mead simplex algorithm with adaptive parameters\". Computational Optimization and Applications [DOI 10.1007/s10589-010-9329-3]", 
            "title": "References"
        }, 
        {
            "location": "/algo/simulated_annealing/", 
            "text": "Simulated Annealing\n\n\n\n\nConstructor\n\n\nSimulatedAnnealing\n(;\n \nneighbor!\n \n=\n \ndefault_neighbor!\n,\n\n                    \nT\n \n=\n \ndefault_temperature\n,\n\n                    \np\n \n=\n \nkirkpatrick\n)\n\n\n\n\n\n\nThe constructor takes three keywords:\n\n\n\n\nneighbor! = a!(x_proposed, x_current)\n, a mutating function of the current x, and the proposed x\n\n\nT = b(iteration)\n, a function of the current iteration that returns a temperature\n\n\np = c(f_proposal, f_current, T)\n, a function of the current temperature, current function value and proposed function value that returns an acceptance probability\n\n\n\n\n\n\nDescription\n\n\nSimulated Annealing is a derivative free method for optimization. It is based on the Metropolis-Hastings algorithm that was originally used to generate samples from a thermodynamics system, and is often used to generate draws from a posterior when doing Bayesian inference. As such, it is a probabilistic method for finding the minimum of a function, often over a quite large domains. For the historical reasons given above, the algorithm uses terms such as cooling, temperature, and acceptance probabilities.\n\n\nAs the constructor shows, a simulated annealing implementation is characterized by a temperature, a neighbor function, and an acceptance probability. The temperature controls how volatile the changes in minimizer candidates are allowed to be, as it enters the acceptance probability. For example, the original Kirkpatrick et al. acceptance probability function can be written as follows\n\n\np\n(\nf_proposal\n,\n \nf_current\n,\n \nT\n)\n \n=\n \nexp\n(\n-\n(\nf_proposal\n \n-\n \nf_current\n)\n/\nT\n)\n\n\n\n\n\n\nA high temperature makes it more likely that a draw is accepted, by pushing acceptance probability to 1. As in the Metropolis-Hastings algorithm, we always accept a smaller function value, but we also sometimes accept a larger value. As the temperature decreases, we're more and more likely to only accept candidate \nx\n's that lowers the function value. To obtain a new \nf_proposal\n, we need a neighbor function. A simple neighbor function adds a standard normal draw to each dimension of \nx\n\n\nfunction\n neighbor\n!\n(\nx_proposal\n::\nArray\n,\n \nx\n::\nArray\n)\n\n    \nfor\n \ni\n \nin\n \neachindex\n(\nx\n)\n\n        \nx_proposal\n[\ni\n]\n \n=\n \nx\n[\ni\n]\n+\nrandn\n()\n\n    \nend\n\n\nend\n\n\n\n\n\n\nAs we see, it is not really possible to disentangle the role of the different components of the algorithm. For example, both the functional form of the acceptance function, the temperature and (indirectly) the neighbor function determine if the next draw of \nx\n is accepted or not.\n\n\nThe current implementation of Simulated Annealing is very rough.  It lacks quite a few features which are normally part of a proper SA implementation. A better implementation is under way, see \nthis issue\n.\n\n\n\n\nExample\n\n\n\n\nReferences", 
            "title": "Simulated Annealing"
        }, 
        {
            "location": "/algo/simulated_annealing/#simulated-annealing", 
            "text": "", 
            "title": "Simulated Annealing"
        }, 
        {
            "location": "/algo/simulated_annealing/#constructor", 
            "text": "SimulatedAnnealing (;   neighbor!   =   default_neighbor! , \n                     T   =   default_temperature , \n                     p   =   kirkpatrick )   The constructor takes three keywords:   neighbor! = a!(x_proposed, x_current) , a mutating function of the current x, and the proposed x  T = b(iteration) , a function of the current iteration that returns a temperature  p = c(f_proposal, f_current, T) , a function of the current temperature, current function value and proposed function value that returns an acceptance probability", 
            "title": "Constructor"
        }, 
        {
            "location": "/algo/simulated_annealing/#description", 
            "text": "Simulated Annealing is a derivative free method for optimization. It is based on the Metropolis-Hastings algorithm that was originally used to generate samples from a thermodynamics system, and is often used to generate draws from a posterior when doing Bayesian inference. As such, it is a probabilistic method for finding the minimum of a function, often over a quite large domains. For the historical reasons given above, the algorithm uses terms such as cooling, temperature, and acceptance probabilities.  As the constructor shows, a simulated annealing implementation is characterized by a temperature, a neighbor function, and an acceptance probability. The temperature controls how volatile the changes in minimizer candidates are allowed to be, as it enters the acceptance probability. For example, the original Kirkpatrick et al. acceptance probability function can be written as follows  p ( f_proposal ,   f_current ,   T )   =   exp ( - ( f_proposal   -   f_current ) / T )   A high temperature makes it more likely that a draw is accepted, by pushing acceptance probability to 1. As in the Metropolis-Hastings algorithm, we always accept a smaller function value, but we also sometimes accept a larger value. As the temperature decreases, we're more and more likely to only accept candidate  x 's that lowers the function value. To obtain a new  f_proposal , we need a neighbor function. A simple neighbor function adds a standard normal draw to each dimension of  x  function  neighbor ! ( x_proposal :: Array ,   x :: Array ) \n     for   i   in   eachindex ( x ) \n         x_proposal [ i ]   =   x [ i ] + randn () \n     end  end   As we see, it is not really possible to disentangle the role of the different components of the algorithm. For example, both the functional form of the acceptance function, the temperature and (indirectly) the neighbor function determine if the next draw of  x  is accepted or not.  The current implementation of Simulated Annealing is very rough.  It lacks quite a few features which are normally part of a proper SA implementation. A better implementation is under way, see  this issue .", 
            "title": "Description"
        }, 
        {
            "location": "/algo/simulated_annealing/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/algo/simulated_annealing/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/algo/gradientdescent/", 
            "text": "Gradient Descent\n\n\n\n\nConstructor\n\n\nGradientDescent\n(;\n \nlinesearch!\n::\nFunction\n \n=\n \nhz_linesearch!\n,\n\n                  \nP\n \n=\n \nnothing\n,\n\n                  \nprecondprep!\n \n=\n \n(\nP\n,\n \nx\n)\n \n-\n \nnothing\n)\n\n\n\n\n\n\n\n\nDescription\n\n\nGradient Descent a common name for a quasi-Newton solver. This means that it takes steps according to\n\n\n$ x_{n+1} = x_n - P^{-1}\\nabla f(x_n)$\n\n\nwhere $P$ is a positive definite matrix. If $P$ is the Hessian, we get Newton's method. In Gradient Descent, $P$ is simply an appropriately dimensioned identity matrix, such that we go in the exact opposite direction of the gradient. This means that we do not use the curvature information from the Hessian, or an approximation of it. While it does seem quite logical to go in the opposite direction of the fastest increase in objective value, the procedure can be very slow if the problem is ill-conditioned. See the section on preconditioners for ways to remedy this when using Gradient Descent.\n\n\nAs with the other quasi-Newton solvers in this package, a scalar $\\alpha$ is introduced as follows\n\n\n$ x_{n+1} = x_n - \\alpha P^{-1}\\nabla f(x_n)$\n\n\nand is chosen by a linesearch algorithm such that each step gives sufficient descent.\n\n\n\n\nExample\n\n\n\n\nReferences", 
            "title": "Gradient Descent"
        }, 
        {
            "location": "/algo/gradientdescent/#gradient-descent", 
            "text": "", 
            "title": "Gradient Descent"
        }, 
        {
            "location": "/algo/gradientdescent/#constructor", 
            "text": "GradientDescent (;   linesearch! :: Function   =   hz_linesearch! , \n                   P   =   nothing , \n                   precondprep!   =   ( P ,   x )   -   nothing )", 
            "title": "Constructor"
        }, 
        {
            "location": "/algo/gradientdescent/#description", 
            "text": "Gradient Descent a common name for a quasi-Newton solver. This means that it takes steps according to  $ x_{n+1} = x_n - P^{-1}\\nabla f(x_n)$  where $P$ is a positive definite matrix. If $P$ is the Hessian, we get Newton's method. In Gradient Descent, $P$ is simply an appropriately dimensioned identity matrix, such that we go in the exact opposite direction of the gradient. This means that we do not use the curvature information from the Hessian, or an approximation of it. While it does seem quite logical to go in the opposite direction of the fastest increase in objective value, the procedure can be very slow if the problem is ill-conditioned. See the section on preconditioners for ways to remedy this when using Gradient Descent.  As with the other quasi-Newton solvers in this package, a scalar $\\alpha$ is introduced as follows  $ x_{n+1} = x_n - \\alpha P^{-1}\\nabla f(x_n)$  and is chosen by a linesearch algorithm such that each step gives sufficient descent.", 
            "title": "Description"
        }, 
        {
            "location": "/algo/gradientdescent/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/algo/gradientdescent/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/algo/lbfgs/", 
            "text": "(L-)BFGS\n\n\nThis page contains information about BFGS and its limited memory version L-BFGS.\n\n\n\n\nConstructors\n\n\nBFGS\n(;\n \nlinesearch!\n \n=\n \nhz_linesearch!\n,\n\n       \nP\n \n=\n \nnothing\n,\n\n       \nprecondprep!\n \n=\n \n(\nP\n,\n \nx\n)\n \n-\n \nnothing\n)\n\n\n\n\n\n\nLBFGS\n(;\n \nm\n \n=\n \n10\n,\n\n        \nlinesearch!\n \n=\n \nhz_linesearch!\n,\n\n        \nP\n \n=\n \nnothing\n,\n\n        \nprecondprep!\n \n=\n \n(\nP\n,\n \nx\n)\n \n-\n \nnothing\n)\n\n\n\n\n\n\n\n\nDescription\n\n\nThis means that it takes steps according to\n\n\n$ x_{n+1} = x_n - P^{-1}\\nabla f(x_n)$\n\n\nwhere $P$ is a positive definite matrix. If $P$ is the Hessian, we get Newton's method. In (L-)BFGS, the matrix is an approximation to the Hessian built using differences in the gradient across iterations. As long as the initial matrix is positive definite  it is possible to show that all the follow matrices will be as well. The starting matrix could simply be the identity matrix, such that the first step is identical to the Gradient Descent algorithm, or even the actual Hessian.\n\n\nThere are two versions of BFGS in the package: BFGS, and L-BFGS. The latter is different from the former because it doesn't use a complete history of the iterative procedure to construct $P$, but rather only the latest $m$ steps. It doesn't actually build the Hessian approximation matrix either, but computes the direction directly. This makes more suitable for large scale problems, as the memory requirement to store the relevant vectors will grow quickly in large problems.\n\n\nAs with the other quasi-Newton solvers in this package, a scalar $\\alpha$ is introduced as follows\n\n\n$ x_{n+1} = x_n - \\alpha P^{-1}\\nabla f(x_n)$\n\n\nand is chosen by a linesearch algorithm such that each step gives sufficient descent.\n\n\n\n\nExample\n\n\n\n\nReferences\n\n\nWright, Stephen, and Jorge Nocedal (2006) \"Numerical optimization.\" Springer", 
            "title": "(L-)BFGS"
        }, 
        {
            "location": "/algo/lbfgs/#l-bfgs", 
            "text": "This page contains information about BFGS and its limited memory version L-BFGS.", 
            "title": "(L-)BFGS"
        }, 
        {
            "location": "/algo/lbfgs/#constructors", 
            "text": "BFGS (;   linesearch!   =   hz_linesearch! , \n        P   =   nothing , \n        precondprep!   =   ( P ,   x )   -   nothing )   LBFGS (;   m   =   10 , \n         linesearch!   =   hz_linesearch! , \n         P   =   nothing , \n         precondprep!   =   ( P ,   x )   -   nothing )", 
            "title": "Constructors"
        }, 
        {
            "location": "/algo/lbfgs/#description", 
            "text": "This means that it takes steps according to  $ x_{n+1} = x_n - P^{-1}\\nabla f(x_n)$  where $P$ is a positive definite matrix. If $P$ is the Hessian, we get Newton's method. In (L-)BFGS, the matrix is an approximation to the Hessian built using differences in the gradient across iterations. As long as the initial matrix is positive definite  it is possible to show that all the follow matrices will be as well. The starting matrix could simply be the identity matrix, such that the first step is identical to the Gradient Descent algorithm, or even the actual Hessian.  There are two versions of BFGS in the package: BFGS, and L-BFGS. The latter is different from the former because it doesn't use a complete history of the iterative procedure to construct $P$, but rather only the latest $m$ steps. It doesn't actually build the Hessian approximation matrix either, but computes the direction directly. This makes more suitable for large scale problems, as the memory requirement to store the relevant vectors will grow quickly in large problems.  As with the other quasi-Newton solvers in this package, a scalar $\\alpha$ is introduced as follows  $ x_{n+1} = x_n - \\alpha P^{-1}\\nabla f(x_n)$  and is chosen by a linesearch algorithm such that each step gives sufficient descent.", 
            "title": "Description"
        }, 
        {
            "location": "/algo/lbfgs/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/algo/lbfgs/#references", 
            "text": "Wright, Stephen, and Jorge Nocedal (2006) \"Numerical optimization.\" Springer", 
            "title": "References"
        }, 
        {
            "location": "/algo/newton/", 
            "text": "Newton's Method\n\n\n\n\nConstructor\n\n\nNewton\n(;\n \nlinesearch!\n \n=\n \nhz_linesearch!\n)\n\n\n\n\n\n\nThe constructor takes one keyword\n\n\n\n\nlinesearch! = a(d, x, p, x_new, g_new, lsr, c, mayterminate)\n, a function performing line search, see the line search section.\n\n\n\n\n\n\nDescription\n\n\nNewton's method for optimization has a long history, and is in some sense the gold standard in unconstrained optimization of smooth functions, at least from a theoretical viewpoint. The main benefit is that it has a quadratic rate of convergence near a local optimum. The main disadvantage is that the user has to provide a Hessian. This can be difficult, complicated, or simply annoying. It can also be computationally expensive to calculate it.\n\n\nNewton's method for optimization consists of applying Newton's method for solving systems of equations, where the equations are the first order conditions, saying that the gradient should equal the zero vector.\n\n\n$ \\nabla f(x) = 0 $\n\n\nA second order Taylor expansion of the left-hand side leads to the iterative scheme\n\n\n$ x_{n+1} = x_n - H(x_n)^{-1}\\nabla f(x_n)$\n\n\nwhere the inverse is not calculated directly, but the step size is instead calculated by solving\n\n\n$ H(x) \\textbf{s} = \\nabla f(x_n) $.\n\n\nThis is equivalent to minimizing a quadratic model, $m_k$ around the current $x_n$\n\n\n$ m_k(s) = f(x_n) + \\nabla f(x_n)^\\top \\textbf{s} + \\frac{1}{2} \\textbf{s}^\\top H(x_n) \\textbf{s} $\n\n\nFor functions where $H(x_n)$ is difficult, or computationally expensive to obtain, we might replace the Hessian with another positive definite matrix that approximates it. Such methods are called Quasi-Newton methods; see (L-)BFGS and Gradient Descent.\n\n\nIn a sufficiently small neighborhood around the minimizer, Newton's method has quadratic convergence, but globally it might have slower convergence, or it might even diverge. To ensure convergence, a line search is performed for each $\\textbf{s}$. This amounts to replacing the step formula above with\n\n\n$ x_{n+1} = x_n - \\alpha \\textbf{s}$\n\n\nand finding a scalar $\\alpha$ such that we get sufficient descent; see the line search section for more information.\n\n\nAdditionally, if the function is locally concave, the step taken in the formulas above will go in a direction of ascent,  as the Hessian will not be positive (semi)definite. To avoid this, we use a specialized method to calculate the step direction. If the Hessian is positive semidefinite then the method used is standard, but if it is not, a correction is made using the functionality in \nPositiveFactorizations.jl\n.\n\n\n\n\nExample\n\n\nshow the example from the issue\n\n\n\n\nReferences", 
            "title": "Newton"
        }, 
        {
            "location": "/algo/newton/#newtons-method", 
            "text": "", 
            "title": "Newton's Method"
        }, 
        {
            "location": "/algo/newton/#constructor", 
            "text": "Newton (;   linesearch!   =   hz_linesearch! )   The constructor takes one keyword   linesearch! = a(d, x, p, x_new, g_new, lsr, c, mayterminate) , a function performing line search, see the line search section.", 
            "title": "Constructor"
        }, 
        {
            "location": "/algo/newton/#description", 
            "text": "Newton's method for optimization has a long history, and is in some sense the gold standard in unconstrained optimization of smooth functions, at least from a theoretical viewpoint. The main benefit is that it has a quadratic rate of convergence near a local optimum. The main disadvantage is that the user has to provide a Hessian. This can be difficult, complicated, or simply annoying. It can also be computationally expensive to calculate it.  Newton's method for optimization consists of applying Newton's method for solving systems of equations, where the equations are the first order conditions, saying that the gradient should equal the zero vector.  $ \\nabla f(x) = 0 $  A second order Taylor expansion of the left-hand side leads to the iterative scheme  $ x_{n+1} = x_n - H(x_n)^{-1}\\nabla f(x_n)$  where the inverse is not calculated directly, but the step size is instead calculated by solving  $ H(x) \\textbf{s} = \\nabla f(x_n) $.  This is equivalent to minimizing a quadratic model, $m_k$ around the current $x_n$  $ m_k(s) = f(x_n) + \\nabla f(x_n)^\\top \\textbf{s} + \\frac{1}{2} \\textbf{s}^\\top H(x_n) \\textbf{s} $  For functions where $H(x_n)$ is difficult, or computationally expensive to obtain, we might replace the Hessian with another positive definite matrix that approximates it. Such methods are called Quasi-Newton methods; see (L-)BFGS and Gradient Descent.  In a sufficiently small neighborhood around the minimizer, Newton's method has quadratic convergence, but globally it might have slower convergence, or it might even diverge. To ensure convergence, a line search is performed for each $\\textbf{s}$. This amounts to replacing the step formula above with  $ x_{n+1} = x_n - \\alpha \\textbf{s}$  and finding a scalar $\\alpha$ such that we get sufficient descent; see the line search section for more information.  Additionally, if the function is locally concave, the step taken in the formulas above will go in a direction of ascent,  as the Hessian will not be positive (semi)definite. To avoid this, we use a specialized method to calculate the step direction. If the Hessian is positive semidefinite then the method used is standard, but if it is not, a correction is made using the functionality in  PositiveFactorizations.jl .", 
            "title": "Description"
        }, 
        {
            "location": "/algo/newton/#example", 
            "text": "show the example from the issue", 
            "title": "Example"
        }, 
        {
            "location": "/algo/newton/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/algo/linesearch/", 
            "text": "Line search\n\n\n\n\nDescription\n\n\n\n\nAvailable line search algorithms\n\n\n\n\nhz_linesearch!\n , the default line search algorithm\n\n\nbacktracking_linesearch!\n\n\ninterpolating_linesearch!\n\n\nmt_linesearch!\n\n\n\n\nThe default line search algorithm is taken from the Conjugate Gradient implementation by Hager and Zhang (HZ).\n\n\n\n\nExample\n\n\n\n\nReferences\n\n\nW. W. Hager and H. Zhang (2006) \"Algorithm 851: CG_DESCENT, a conjugate gradient method with guaranteed descent.\"\" ACM Transactions on Mathematical Software 32: 113-137. Wright, Stephen, and Jorge Nocedal (2006) \"Numerical optimization.\" Springer", 
            "title": "Linesearch"
        }, 
        {
            "location": "/algo/linesearch/#line-search", 
            "text": "", 
            "title": "Line search"
        }, 
        {
            "location": "/algo/linesearch/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/algo/linesearch/#available-line-search-algorithms", 
            "text": "hz_linesearch!  , the default line search algorithm  backtracking_linesearch!  interpolating_linesearch!  mt_linesearch!   The default line search algorithm is taken from the Conjugate Gradient implementation by Hager and Zhang (HZ).", 
            "title": "Available line search algorithms"
        }, 
        {
            "location": "/algo/linesearch/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/algo/linesearch/#references", 
            "text": "W. W. Hager and H. Zhang (2006) \"Algorithm 851: CG_DESCENT, a conjugate gradient method with guaranteed descent.\"\" ACM Transactions on Mathematical Software 32: 113-137. Wright, Stephen, and Jorge Nocedal (2006) \"Numerical optimization.\" Springer", 
            "title": "References"
        }, 
        {
            "location": "/algo/precondition/", 
            "text": "Preconditioning\n\n\nThe \nGradientDescent\n, \nConjugateGradient\n and \nLBFGS\n methods support preconditioning. A preconditioner can be thought of as a change of coordinates under which the Hessian is better conditioned. With a good preconditioner substantially improved convergence is possible.\n\n\nA preconditioner \nP\ncan be of any type as long as the following two methods are implemented:\n\n\n\n\nA_ldiv_B!(pgr, P, gr)\n : apply \nP\n to a vector \ngr\n and store in \npgr\n       (intuitively, \npgr = P \\ gr\n)\n\n\ndot(x, P, y)\n : the inner product induced by \nP\n       (intuitively, \ndot(x, P * y)\n)\n\n\n\n\nPrecisely what these operations mean, depends on how \nP\n is stored. Commonly, we store a matrix \nP\n which approximates the Hessian in some vague sense. In this case,\n\n\n\n\nA_ldiv_B!(pgr, P, gr) = copy!(pgr, P \\ A)\n\n\ndot(x, P, y) = dot(x, P * y)\n\n\n\n\nFinally, it is possible to update the preconditioner as the state variable \nx\n changes. This is done through  \nprecondprep!\n which is passed to the optimizers as kw-argument, e.g.,\n\n\n   \nmethod\n=\nConjugateGradient\n(\nP\n \n=\n \nprecond\n(\n100\n),\n \nprecondprep!\n \n=\n \nprecond\n(\n100\n))\n\n\n\n\n\n\nthough in this case it would always return the same matrix. (See \nfminbox.jl\n for a more natural example.)\n\n\nApart from preconditioning with matrices, \nOptim.jl\n provides a type \nInverseDiagonal\n, which represents a diagonal matrix by its inverse elements.\n\n\n\n\nExample\n\n\nBelow, we see an example where a function is minimized without and with a preconditioner applied.\n\n\nusing\n \nForwardDiff\n\n\nplap\n(\nU\n;\n \nn\n \n=\n \nlength\n(\nU\n))\n \n=\n \n(\nn\n-\n1\n)\n*\nsum\n((\n0.1\n \n+\n \ndiff\n(\nU\n)\n.^\n2\n)\n.^\n2\n \n)\n \n-\n \nsum\n(\nU\n)\n \n/\n \n(\nn\n-\n1\n)\n\n\nplap1\n \n=\n \nForwardDiff\n.\ngradient\n(\nplap\n)\n\n\nprecond\n(\nn\n)\n \n=\n \nspdiagm\n((\n-\nones\n(\nn\n-\n1\n),\n \n2\n*\nones\n(\nn\n),\n \n-\nones\n(\nn\n-\n1\n)),\n \n(\n-\n1\n,\n0\n,\n1\n),\n \nn\n,\n \nn\n)\n*\n(\nn\n+\n1\n)\n\n\ndf\n \n=\n \nDifferentiableFunction\n(\nx\n \n-\n \nplap\n([\n0\n;\n \nX\n;\n \n0\n]),\n\n                            \n(\nx\n,\n \ng\n)\n \n-\n \ncopy!\n(\ng\n,\n \n(\nplap1\n([\n0\n;\n \nX\n;\n \n0\n]))[\n2\n:\nend\n-\n1\n]))\n\n\nresult\n \n=\n \nOptim\n.\noptimize\n(\ndf\n,\n \nzeros\n(\n100\n),\n \nmethod\n \n=\n \nConjugateGradient\n(\nP\n \n=\n \nnothing\n))\n\n\nresult\n \n=\n \nOptim\n.\noptimize\n(\ndf\n,\n \nzeros\n(\n100\n),\n \nmethod\n \n=\n \nConjugateGradient\n(\nP\n \n=\n \nprecond\n(\n100\n)))\n\n\n\n\n\n\nThe former optimize call converges at a slower rate than the latter. Looking at a  plot of the 2D version of the function shows the problem.\n\n\n\n\nThe contours are shaped like ellipsoids, but we would rather want them to be circles. Using the preconditioner effectively changes the coordinates such that the contours becomes less ellipsoid-like. Benchmarking shows that using preconditioning provides  an approximate speed-up factor of 15 in this 100 dimensional case.\n\n\n\n\nReferences", 
            "title": "Preconditioners"
        }, 
        {
            "location": "/algo/precondition/#preconditioning", 
            "text": "The  GradientDescent ,  ConjugateGradient  and  LBFGS  methods support preconditioning. A preconditioner can be thought of as a change of coordinates under which the Hessian is better conditioned. With a good preconditioner substantially improved convergence is possible.  A preconditioner  P can be of any type as long as the following two methods are implemented:   A_ldiv_B!(pgr, P, gr)  : apply  P  to a vector  gr  and store in  pgr        (intuitively,  pgr = P \\ gr )  dot(x, P, y)  : the inner product induced by  P        (intuitively,  dot(x, P * y) )   Precisely what these operations mean, depends on how  P  is stored. Commonly, we store a matrix  P  which approximates the Hessian in some vague sense. In this case,   A_ldiv_B!(pgr, P, gr) = copy!(pgr, P \\ A)  dot(x, P, y) = dot(x, P * y)   Finally, it is possible to update the preconditioner as the state variable  x  changes. This is done through   precondprep!  which is passed to the optimizers as kw-argument, e.g.,      method = ConjugateGradient ( P   =   precond ( 100 ),   precondprep!   =   precond ( 100 ))   though in this case it would always return the same matrix. (See  fminbox.jl  for a more natural example.)  Apart from preconditioning with matrices,  Optim.jl  provides a type  InverseDiagonal , which represents a diagonal matrix by its inverse elements.", 
            "title": "Preconditioning"
        }, 
        {
            "location": "/algo/precondition/#example", 
            "text": "Below, we see an example where a function is minimized without and with a preconditioner applied.  using   ForwardDiff  plap ( U ;   n   =   length ( U ))   =   ( n - 1 ) * sum (( 0.1   +   diff ( U ) .^ 2 ) .^ 2   )   -   sum ( U )   /   ( n - 1 )  plap1   =   ForwardDiff . gradient ( plap )  precond ( n )   =   spdiagm (( - ones ( n - 1 ),   2 * ones ( n ),   - ones ( n - 1 )),   ( - 1 , 0 , 1 ),   n ,   n ) * ( n + 1 )  df   =   DifferentiableFunction ( x   -   plap ([ 0 ;   X ;   0 ]), \n                             ( x ,   g )   -   copy! ( g ,   ( plap1 ([ 0 ;   X ;   0 ]))[ 2 : end - 1 ]))  result   =   Optim . optimize ( df ,   zeros ( 100 ),   method   =   ConjugateGradient ( P   =   nothing ))  result   =   Optim . optimize ( df ,   zeros ( 100 ),   method   =   ConjugateGradient ( P   =   precond ( 100 )))   The former optimize call converges at a slower rate than the latter. Looking at a  plot of the 2D version of the function shows the problem.   The contours are shaped like ellipsoids, but we would rather want them to be circles. Using the preconditioner effectively changes the coordinates such that the contours becomes less ellipsoid-like. Benchmarking shows that using preconditioning provides  an approximate speed-up factor of 15 in this 100 dimensional case.", 
            "title": "Example"
        }, 
        {
            "location": "/algo/precondition/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/dev/contributing/", 
            "text": "Notes for contributing\n\n\n\n\nAdd a note in NEWS.md\n\n\nIf a change is more than just changing a typo, it will often be required to add a bullet point to the \nNEWS.md\n file at the root of the repository. This makes it easier for users to keep track of the changes since last version. A short description, and a link to the PR or issue is sufficient.\n\n\n\n\nAdding a solver\n\n\nIf you're contributing a new solver, you shouldn't need to touch any of the code in \nsrc/optimize.jl\n. You should rather add a file named (\nsolver\n is the name of the solver) \nsolver.jl\n in \nsrc\n, and make sure that you define a trace macro \nsolvertrace\n, an \nOptimizer\n subtype \nimmutable Solver \n: Optimizer end\n with appropriate fields, a default constructor with a keyword for each field, and an \noptimize\n method. Say you want to contribute a solver called \nMinim\n, then your \nsrc/minim.jl\n file would look something like\n\n\nmacro minimtrace()\n    quote\n        if tracing\n            dt = Dict()\n            if o.extended_trace\n                dt[\nx\n] = copy(x)\n                dt[\ng(x)\n] = copy(g)\n                dt[\n~inv(H)\n] = copy(invH)\n            end\n            g_norm = vecnorm(g, Inf)\n            update!(tr,\n                    iteration,\n                    f_x,\n                    g_norm,\n                    dt,\n                    o.store_trace,\n                    o.show_trace,\n                    o.show_every,\n                    o.callback)\n        end\n    end\nend\n\nimmutable Minim{T} \n: Optimizer\n    linesearch!::Function\n    minim_parameter::T\nend\n\nMinim(; linesearch!::Function = hz_linesearch!, minim_parameter = 1.0) =\n  Minim(linesearch!, minim_parameter)\n\nfunction optimize{T}(d::DifferentiableFunction,\n                     initial_x::Vector{T},\n                     mo::Minim,\n                     o::OptimizationOptions)\n    ...\nend", 
            "title": "Contributing"
        }, 
        {
            "location": "/dev/contributing/#notes-for-contributing", 
            "text": "", 
            "title": "Notes for contributing"
        }, 
        {
            "location": "/dev/contributing/#add-a-note-in-newsmd", 
            "text": "If a change is more than just changing a typo, it will often be required to add a bullet point to the  NEWS.md  file at the root of the repository. This makes it easier for users to keep track of the changes since last version. A short description, and a link to the PR or issue is sufficient.", 
            "title": "Add a note in NEWS.md"
        }, 
        {
            "location": "/dev/contributing/#adding-a-solver", 
            "text": "If you're contributing a new solver, you shouldn't need to touch any of the code in  src/optimize.jl . You should rather add a file named ( solver  is the name of the solver)  solver.jl  in  src , and make sure that you define a trace macro  solvertrace , an  Optimizer  subtype  immutable Solver  : Optimizer end  with appropriate fields, a default constructor with a keyword for each field, and an  optimize  method. Say you want to contribute a solver called  Minim , then your  src/minim.jl  file would look something like  macro minimtrace()\n    quote\n        if tracing\n            dt = Dict()\n            if o.extended_trace\n                dt[ x ] = copy(x)\n                dt[ g(x) ] = copy(g)\n                dt[ ~inv(H) ] = copy(invH)\n            end\n            g_norm = vecnorm(g, Inf)\n            update!(tr,\n                    iteration,\n                    f_x,\n                    g_norm,\n                    dt,\n                    o.store_trace,\n                    o.show_trace,\n                    o.show_every,\n                    o.callback)\n        end\n    end\nend\n\nimmutable Minim{T}  : Optimizer\n    linesearch!::Function\n    minim_parameter::T\nend\n\nMinim(; linesearch!::Function = hz_linesearch!, minim_parameter = 1.0) =\n  Minim(linesearch!, minim_parameter)\n\nfunction optimize{T}(d::DifferentiableFunction,\n                     initial_x::Vector{T},\n                     mo::Minim,\n                     o::OptimizationOptions)\n    ...\nend", 
            "title": "Adding a solver"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "Optim.jl is licensed under the MIT License:\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \nSoftware\n), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}